---
created: 2024-08-31T17:09
updated: 2024-09-01T15:45
---
关于智能指针中的基础知识可以看一下[[C++对象生存周期]]
# 智能指针 unique_ptr
`unique_ptr`是作用域指针，超过作用域时会进行销毁，在[[C++对象生存周期]]中提及的作用域指针其实就是unique_ptr。
unique_ptr指针从字面意思理解就是指该指针是独一无二的，而事实上也确实如此。**unique_ptr指针不能复制**，因为复制之后两者指向的是同一个内存空间，当其中一个指针关闭时，会销毁指向的内存空间，导致两者指向已回收的内存。
```cpp
#include<memory>
class Entity
{
public:
    Entity()
    {
        std::cout << "创建对象" << std::endl;
    }
    ~Entity()
    {
        std::cout << "销毁对象" << std::endl;
    }
    void print() {}
};

int main()
{
    {
        std::unique_ptr<Entity> entity(new Entity());
        //使用make_unique创建unique_ptr会更加安全
        //可避免构造函数异常时变成没有引用的悬空指针
        std::unique_ptr<Entity> entity = std::make_unique<Entity>();
		//下列做法是错误的
		std::unique_ptr<Entity> e0 = entity;    
        entity->print();
    }
}
```
# 智能指针 shared_ptr
`Shared_ptr` 相比 unique_ptr，可以从字面意思上看出 shared_ptr 可以共享（复制）。Shared_ptr 通过引用计数来决定是否销毁，如果没有对象引用该指针，即引用计数为 0 时，指针将会自动销毁。

```cpp
#include<memory>
class Entity
{
public:
    Entity()
    {
        std::cout << "创建对象" << std::endl;
    }
    ~Entity()
    {
        std::cout << "销毁对象" << std::endl;
    }
    void print() {}
};

int main()
{
    {
        std::unique_ptr<Entity> entity(new Entity());
        //使用make_unique创建unique_ptr会更加安全
        //可避免构造函数异常时变成没有引用的悬空指针
        std::unique_ptr<Entity> entity = std::make_unique<Entity>();
		//下列做法是错误的
		std::unique_ptr<Entity> e0 = entity;    
        entity->print();
    }
}
```
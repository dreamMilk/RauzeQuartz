动态链接是链接发生在运行时，静态链接是发生在编译时
静态链接存在更多的优化空间，因为编译器和链接器可以从静态链接中看到更多内容，尤其是链接器
动态链接发生在运行时，意味着只有真正启动可执行文件才会加载动态链接库，它实际上并不是可执行文件的一部分
当启动可执行文件时，可执行文件会被加载到内存中，采用动态链接时，会将动态链接库也加载到内存中，

明确程序所需的库，进行动态链接
动态链接更像是“静态链接”了动态库，通过链接静态 lib 文件，知晓函数指针与动态库的对应关系，然后在运行时去调用动态库中的内容
因此相较于[[静态库使用#^a06088|静态库设置]]只需要将 `glfw3.lib` 换成 `glfw3dll.lib`，并且将其对应的 `glfw3.dll` 与可执行文件放在同一个路径下，否则会出现 dll 缺失的错误

```cpp
/* GLFWAPI is used to declare public API functions for export
 * from the DLL / shared library / dynamic library.
 */
#if defined(_WIN32) && defined(_GLFW_BUILD_DLL)
 /* We are building GLFW as a Win32 DLL */
 #define GLFWAPI __declspec(dllexport)
#elif defined(_WIN32) && defined(GLFW_DLL)
 /* We are calling a GLFW Win32 DLL */
 #define GLFWAPI __declspec(dllimport)
#elif defined(__GNUC__) && defined(_GLFW_BUILD_DLL)
 /* We are building GLFW as a Unix shared library */
 #define GLFWAPI __attribute__((visibility("default")))
#else
 #define GLFWAPI
#endif
```

当我们预定义 `#define GLFW_DLL` 时，上述代码会执行 `#define GLFWAPI` 语句，即不使用 `__declspec(dllimport)`，但是所写的代码仍然可以运行

在使用 lib+dll 时，比较是否使用 `__declspec(dllimport)` 的区别

|      | 使用 `__declspec(dllimport)`        | 不使用 `__declspec(dllimport)` |
| ---- | --------------------------------- | --------------------------- |
| 编译阶段 | 通过 lib 中提供的函数指针，将调用与 dll 中的代码联系起来 | 将调用函数视为                     |

---
aliases: 
tags: 
title: 处理多个返回值
date: 2024-09-25 01:31
updated: 2024-09-25 01:49
---
# 通过参数传出
```cpp
 void func(int arg,std::string& str1,std::string& str2)
 {
 	//相关操作
 	str1 = "result1";
 	str2 = "result2";
 }
 
 int main(){
 	//获取返回结果
 	std::string res1,res2;
 	func(1,res1,res2);
 }
```
使用引用传入不会造成太多的性能损失，是一种简单高效的方式，但存在一个缺点，必须初始化返回结果变量并传入到函数中
在特殊情况下，不需要某些返回值，仍然使用引用传入则不太合适。将引用改为指针，并在输出返回值时选择性输出
```cpp
void func(int arg,std::string* str1,std::string* str2)
{
	//相关操作
	if(str1)
		*str1 = "result1";
	if(str2)
		*str2 = "result2";
}

int main(){
	//获取返回结果
	std::string res1,res2;
	func(1,&res1,&res2);
	//忽略第一个返回值
	func(2,nullptr,&res2);
}
```

# 相同类型返回值
当返回值为多个相同类型值时，可以使用数组传出
```cpp
#include<iostream>  
  
std::string* func(int arg)  
{  
    //相关操作  
    std::string str1 = "result1";  
    std::string str2 = "result2";  
    return new std::string[]{str1,str2};  
}  
  
int main(){  
    //获取返回结果
    std::string* res= func(1);  
}
```

当数组大小确定时，可以使用 `array` 或者 `vector`，`array` 是在栈中分配空间，而 `vector` 是在堆中分配空间

```cpp
#include<iostream>
#include<array>

std::array<std::string, 2> func(int arg)
{
	//相关操作
	std::string str1 = "result1";
	std::string str2 = "result2";
	std::array<std::string,2> result;
	result[0] = str1;
	result[1] = str2;
	return result;
}

int main(){
	//获取返回结果
	std::array<std::string,2> res= func(1);
}
```

上述代码中的 `array` 可以替换成 `vector`，一般情况下 `array` 的运行速度会更快

# 不同类型返回值
## Tuple

## pair